<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>machinevisiontoolbox.ImageProcessingBase &mdash; Machine Vision Toolbox 0.1 documentation</title>
      <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="../../_static/css/theme.css" type="text/css" />
      <link rel="stylesheet" href="../../_static/graphviz.css" type="text/css" />
  <!--[if lt IE 9]>
    <script src="../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script data-url_root="../../" id="documentation_options" src="../../_static/documentation_options.js"></script>
        <script src="../../_static/jquery.js"></script>
        <script src="../../_static/underscore.js"></script>
        <script src="../../_static/_sphinx_javascript_frameworks_compat.js"></script>
        <script src="../../_static/doctools.js"></script>
        <script src="../../_static/sphinx_highlight.js"></script>
    <script src="../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
            <a href="../../index.html" class="icon icon-home"> Machine Vision Toolbox
            <img src="../../_static/VisionToolboxLogo_CircBlack.png" class="logo" alt="Logo"/>
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul>
<li class="toctree-l1"><a class="reference internal" href="../../image_class.html">Class reference</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../camera.html">Camera geometry</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../image_functions.html">Function reference</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">Machine Vision Toolbox</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../index.html" class="icon icon-home"></a></li>
          <li class="breadcrumb-item"><a href="../index.html">Module code</a></li>
      <li class="breadcrumb-item active">machinevisiontoolbox.ImageProcessingBase</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <h1>Source code for machinevisiontoolbox.ImageProcessingBase</h1><div class="highlight"><pre>
<span></span><span class="ch">#!/usr/bin/env python</span>

<span class="kn">from</span> <span class="nn">collections</span> <span class="kn">import</span> <span class="n">namedtuple</span>
<span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">scipy</span> <span class="k">as</span> <span class="nn">sp</span>
<span class="kn">from</span> <span class="nn">scipy</span> <span class="kn">import</span> <span class="n">interpolate</span>
<span class="kn">import</span> <span class="nn">cv2</span> <span class="k">as</span> <span class="nn">cv</span>

<span class="kn">import</span> <span class="nn">spatialmath.base.argcheck</span> <span class="k">as</span> <span class="nn">argcheck</span>
<span class="kn">from</span> <span class="nn">machinevisiontoolbox.base</span> <span class="kn">import</span> <span class="n">color</span><span class="p">,</span> <span class="n">int_image</span><span class="p">,</span> <span class="n">float_image</span><span class="p">,</span> <span class="n">plot_histogram</span>

<div class="viewcode-block" id="ImageProcessingBaseMixin"><a class="viewcode-back" href="../../imageproc.html#machinevisiontoolbox.ImageProcessingBase.ImageProcessingBaseMixin">[docs]</a><span class="k">class</span> <span class="nc">ImageProcessingBaseMixin</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Image processing basic operations on the Image class</span>
<span class="sd">    &quot;&quot;&quot;</span>

<div class="viewcode-block" id="ImageProcessingBaseMixin.int"><a class="viewcode-back" href="../../imageproc.html#machinevisiontoolbox.ImageProcessingBase.ImageProcessingBaseMixin.int">[docs]</a>    <span class="k">def</span> <span class="nf">int</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">intclass</span><span class="o">=</span><span class="s1">&#39;uint8&#39;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Convert image to integer type</span>

<span class="sd">        :param intclass: either &#39;uint8&#39;, or any integer class supported by np</span>
<span class="sd">        :type intclass: str</span>
<span class="sd">        :return: Image with integer pixel types</span>
<span class="sd">        :rtype: Image instance</span>

<span class="sd">        - ``IM.int()`` is a copy of image with pixels converted to unsigned</span>
<span class="sd">          8-bit integer (uint8) elements in the range 0 to 255.</span>

<span class="sd">        - ``IM.int(intclass)`` as above but the output pixels are converted to</span>
<span class="sd">          the integer class ``intclass``.</span>

<span class="sd">        Example:</span>

<span class="sd">        .. runblock:: pycon</span>

<span class="sd">            &gt;&gt;&gt; from machinevisiontoolbox import Image</span>
<span class="sd">            &gt;&gt;&gt; im = Image(&#39;flowers1.png&#39;, dtype=&#39;float64&#39;)</span>
<span class="sd">            &gt;&gt;&gt; print(im)</span>
<span class="sd">            &gt;&gt;&gt; im_int = im.int()</span>
<span class="sd">            &gt;&gt;&gt; print(im_int)</span>

<span class="sd">        .. note::</span>

<span class="sd">            - Works for an image with arbitrary number of dimensions, eg. a</span>
<span class="sd">              color image or image sequence.</span>
<span class="sd">            - If the input image is floating point (single or double) the</span>
<span class="sd">              pixel values are scaled from an input range of [0,1] to a range</span>
<span class="sd">              spanning zero to the maximum positive value of the output integer</span>
<span class="sd">              class.</span>
<span class="sd">            - If the input image is an integer class then the pixels are cast</span>
<span class="sd">              to change type but not their value.</span>

<span class="sd">        :references:</span>

<span class="sd">            - Robotics, Vision &amp; Control, Section 12.1, P. Corke,</span>
<span class="sd">              Springer 2011.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">out</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">im</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">:</span>
            <span class="n">out</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">int_image</span><span class="p">(</span><span class="n">im</span><span class="o">.</span><span class="n">image</span><span class="p">,</span> <span class="n">intclass</span><span class="p">))</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">(</span><span class="n">out</span><span class="p">)</span></div>

<div class="viewcode-block" id="ImageProcessingBaseMixin.float"><a class="viewcode-back" href="../../imageproc.html#machinevisiontoolbox.ImageProcessingBase.ImageProcessingBaseMixin.float">[docs]</a>    <span class="k">def</span> <span class="nf">float</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">floatclass</span><span class="o">=</span><span class="s1">&#39;float32&#39;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Convert image to float type</span>

<span class="sd">        :param floatclass: &#39;single&#39;, &#39;double&#39;, &#39;float32&#39; [default], &#39;float64&#39;</span>
<span class="sd">        :type floatclass: str</span>
<span class="sd">        :return: Image with floating point pixel types</span>
<span class="sd">        :rtype: Image instance</span>

<span class="sd">        - ``IM.float()`` is a copy of image with pixels converted to</span>
<span class="sd">          ``float32`` floating point values spanning the range 0 to 1. The</span>
<span class="sd">          input integer pixels are assumed to span the range 0 to the maximum</span>
<span class="sd">          value of their integer class.</span>

<span class="sd">        - ``IM.float(im, floatclass)`` as above but with floating-point pixel</span>
<span class="sd">          values belonging to the class ``floatclass``.</span>

<span class="sd">        Example:</span>

<span class="sd">        .. runblock:: pycon</span>

<span class="sd">            &gt;&gt;&gt; im = Image(&#39;flowers1.png&#39;)</span>
<span class="sd">            &gt;&gt;&gt; print(im)</span>
<span class="sd">            &gt;&gt;&gt; im_float = im.float()</span>
<span class="sd">            &gt;&gt;&gt; print(im_float)</span>

<span class="sd">        :references:</span>

<span class="sd">            - Robotics, Vision &amp; Control, Section 12.1, P. Corke,</span>
<span class="sd">              Springer 2011.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">out</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">im</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">:</span>
            <span class="n">out</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">float_image</span><span class="p">(</span><span class="n">im</span><span class="o">.</span><span class="n">image</span><span class="p">,</span> <span class="n">floatclass</span><span class="p">))</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">(</span><span class="n">out</span><span class="p">)</span></div>

<div class="viewcode-block" id="ImageProcessingBaseMixin.mono"><a class="viewcode-back" href="../../imageproc.html#machinevisiontoolbox.ImageProcessingBase.ImageProcessingBaseMixin.mono">[docs]</a>    <span class="k">def</span> <span class="nf">mono</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">opt</span><span class="o">=</span><span class="s1">&#39;r601&#39;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Convert color image to monochrome</span>

<span class="sd">        :param opt: greyscale conversion option &#39;r601&#39; [default] or &#39;r709&#39;</span>
<span class="sd">        :type opt: string</span>
<span class="sd">        :return: Image with floating point pixel types</span>
<span class="sd">        :rtype: Image instance</span>

<span class="sd">        - ``IM.mono(im)`` is a greyscale equivalent of the color image ``im``</span>

<span class="sd">        Example:</span>

<span class="sd">        .. runblock:: pycon</span>

<span class="sd">            &gt;&gt;&gt; im = Image(&#39;flowers1.png&#39;)</span>
<span class="sd">            &gt;&gt;&gt; print(im)</span>
<span class="sd">            &gt;&gt;&gt; im_mono = im.mono()</span>
<span class="sd">            &gt;&gt;&gt; print(im_mono)</span>

<span class="sd">        :references:</span>

<span class="sd">            - Robotics, Vision &amp; Control, Section 10.1, P. Corke,</span>
<span class="sd">              Springer 2011.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">iscolor</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span>

        <span class="n">out</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">im</span> <span class="ow">in</span> <span class="p">[</span><span class="n">img</span><span class="o">.</span><span class="n">bgr</span> <span class="k">for</span> <span class="n">img</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">]:</span>
            <span class="k">if</span> <span class="n">opt</span> <span class="o">==</span> <span class="s1">&#39;r601&#39;</span><span class="p">:</span>
                <span class="n">new</span> <span class="o">=</span> <span class="mf">0.229</span> <span class="o">*</span> <span class="n">im</span><span class="p">[:,</span> <span class="p">:,</span> <span class="mi">2</span><span class="p">]</span> <span class="o">+</span> <span class="mf">0.587</span> <span class="o">*</span> <span class="n">im</span><span class="p">[:,</span> <span class="p">:,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">+</span> \
                    <span class="mf">0.114</span> <span class="o">*</span> <span class="n">im</span><span class="p">[:,</span> <span class="p">:,</span> <span class="mi">0</span><span class="p">]</span>
                <span class="n">new</span> <span class="o">=</span> <span class="n">new</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">im</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">opt</span> <span class="o">==</span> <span class="s1">&#39;r709&#39;</span><span class="p">:</span>
                <span class="n">new</span> <span class="o">=</span> <span class="mf">0.2126</span> <span class="o">*</span> <span class="n">im</span><span class="p">[:,</span> <span class="p">:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="mf">0.7152</span> <span class="o">*</span> <span class="n">im</span><span class="p">[:,</span> <span class="p">:,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">+</span> \
                    <span class="mf">0.0722</span> <span class="o">*</span> <span class="n">im</span><span class="p">[:,</span> <span class="p">:,</span> <span class="mi">2</span><span class="p">]</span>
                <span class="n">new</span> <span class="o">=</span> <span class="n">new</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">im</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">opt</span> <span class="o">==</span> <span class="s1">&#39;value&#39;</span><span class="p">:</span>
                <span class="c1"># &#39;value&#39; refers to the V in HSV space, not the CIE L*</span>
                <span class="c1"># the mean of the max and min of RGB values at each pixel</span>
                <span class="n">mn</span> <span class="o">=</span> <span class="n">im</span><span class="p">[:,</span> <span class="p">:,</span> <span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
                <span class="n">mx</span> <span class="o">=</span> <span class="n">im</span><span class="p">[:,</span> <span class="p">:,</span> <span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>

                <span class="c1"># if np.issubdtype(im.dtype, np.float):</span>
                <span class="c1"># NOTE let&#39;s make a new predicate for Image</span>
                <span class="k">if</span> <span class="n">im</span><span class="o">.</span><span class="n">isfloat</span><span class="p">:</span>
                    <span class="n">new</span> <span class="o">=</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="p">(</span><span class="n">mn</span> <span class="o">+</span> <span class="n">mx</span><span class="p">)</span>
                    <span class="n">new</span> <span class="o">=</span> <span class="n">new</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">im</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">z</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">(</span><span class="n">mx</span><span class="p">)</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">(</span><span class="n">mn</span><span class="p">))</span> <span class="o">/</span> <span class="mi">2</span>
                    <span class="n">new</span> <span class="o">=</span> <span class="n">z</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">im</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;unknown type for opt&#39;</span><span class="p">)</span>

            <span class="n">out</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">new</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">(</span><span class="n">out</span><span class="p">)</span></div>

<div class="viewcode-block" id="ImageProcessingBaseMixin.stretch"><a class="viewcode-back" href="../../imageproc.html#machinevisiontoolbox.ImageProcessingBase.ImageProcessingBaseMixin.stretch">[docs]</a>    <span class="k">def</span> <span class="nf">stretch</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="nb">max</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">r</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Image normalisation</span>

<span class="sd">        :param max: M  pixels are mapped to the r 0 to M</span>
<span class="sd">        :type max: scalar integer or float</span>
<span class="sd">        :param r: r[0] is mapped to 0, r[1] is mapped to 1 (or max value)</span>
<span class="sd">        :type r: 2-tuple or numpy array (2,1)</span>
<span class="sd">        :return: Image with pixel values stretched to M across r</span>
<span class="sd">        :rtype: Image instance</span>

<span class="sd">        - ``IM.stretch()`` is a normalised image in which all pixel values lie</span>
<span class="sd">          in the r range of 0 to 1. That is, a linear mapping where the minimum</span>
<span class="sd">          value of ``im`` is mapped to 0 and the maximum value of ``im`` is</span>
<span class="sd">          mapped to 1.</span>

<span class="sd">        Example:</span>

<span class="sd">        .. runblock:: pycon</span>

<span class="sd">        .. note::</span>

<span class="sd">            - For an integer image the result is a float image in the range 0</span>
<span class="sd">              to max value</span>

<span class="sd">        :references:</span>

<span class="sd">            - Robotics, Vision &amp; Control, Section 12.1, P. Corke,</span>
<span class="sd">              Springer 2011.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># TODO make all infinity values = None?</span>

        <span class="n">out</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">im</span> <span class="ow">in</span> <span class="p">[</span><span class="n">img</span><span class="o">.</span><span class="n">image</span> <span class="k">for</span> <span class="n">img</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">]:</span>
            <span class="k">if</span> <span class="n">r</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">mn</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">im</span><span class="p">)</span>
                <span class="n">mx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">im</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">r</span> <span class="o">=</span> <span class="n">argcheck</span><span class="o">.</span><span class="n">getvector</span><span class="p">(</span><span class="n">r</span><span class="p">)</span>
                <span class="n">mn</span> <span class="o">=</span> <span class="n">r</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="n">mx</span> <span class="o">=</span> <span class="n">r</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>

            <span class="n">zs</span> <span class="o">=</span> <span class="p">(</span><span class="n">im</span> <span class="o">-</span> <span class="n">mn</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">mx</span> <span class="o">-</span> <span class="n">mn</span><span class="p">)</span> <span class="o">*</span> <span class="nb">max</span>

            <span class="k">if</span> <span class="n">r</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">zs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">maximum</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">minimum</span><span class="p">(</span><span class="nb">max</span><span class="p">,</span> <span class="n">zs</span><span class="p">))</span>
            <span class="n">out</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">zs</span><span class="p">)</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">(</span><span class="n">out</span><span class="p">)</span></div>

<div class="viewcode-block" id="ImageProcessingBaseMixin.thresh"><a class="viewcode-back" href="../../imageproc.html#machinevisiontoolbox.ImageProcessingBase.ImageProcessingBaseMixin.thresh">[docs]</a>    <span class="k">def</span> <span class="nf">thresh</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">t</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">opt</span><span class="o">=</span><span class="s1">&#39;binary&#39;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Image threshold</span>

<span class="sd">        :param t: threshold</span>
<span class="sd">        :type t: scalar</span>
<span class="sd">        :param opt: threshold option (see below)</span>
<span class="sd">        :type opt: string</span>
<span class="sd">        :return imt: Image thresholded binary image</span>
<span class="sd">        :rtype imt: Image instance</span>
<span class="sd">        :return: threshold if opt is otsu or triangle</span>
<span class="sd">        :rtype: list of scalars</span>

<span class="sd">        - ``IM.thresh()`` uses Otsu&#39;s method for thresholding a greyscale</span>
<span class="sd">          image.</span>

<span class="sd">        - ``IM.thresh(t)`` as above but the threshold ``t`` is specified.</span>

<span class="sd">        - ``IM.thresh(t, opt)`` as above but the threshold option is specified.</span>
<span class="sd">          See opencv threshold types for threshold options</span>
<span class="sd">          https://docs.opencv.org/4.2.0/d7/d1b/group__imgproc__</span>
<span class="sd">          misc.html#gaa9e58d2860d4afa658ef70a9b1115576</span>

<span class="sd">        Example:</span>

<span class="sd">        .. runblock:: pycon</span>

<span class="sd">        :options:</span>

<span class="sd">            - &#39;binary&#39; # TODO consider the LaTeX formatting of equations</span>
<span class="sd">            - &#39;binary_inv&#39;</span>
<span class="sd">            - &#39;trunc&#39;</span>
<span class="sd">            - &#39;tozero&#39;</span>
<span class="sd">            - &#39;tozero_inv&#39;</span>
<span class="sd">            - &#39;otsu&#39;</span>
<span class="sd">            - &#39;triangle&#39;</span>

<span class="sd">        .. note::</span>

<span class="sd">            - Converts a color image to greyscale.</span>
<span class="sd">            - For a uint8 class image the slider range is 0 to 255.</span>
<span class="sd">            - For a floating point class image the slider range is 0 to 1.0</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># dictionary of threshold options from OpenCV</span>
        <span class="n">threshopt</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s1">&#39;binary&#39;</span><span class="p">:</span> <span class="n">cv</span><span class="o">.</span><span class="n">THRESH_BINARY</span><span class="p">,</span>
            <span class="s1">&#39;binary_inv&#39;</span><span class="p">:</span> <span class="n">cv</span><span class="o">.</span><span class="n">THRESH_BINARY_INV</span><span class="p">,</span>
            <span class="s1">&#39;trunc&#39;</span><span class="p">:</span> <span class="n">cv</span><span class="o">.</span><span class="n">THRESH_TRUNC</span><span class="p">,</span>
            <span class="s1">&#39;tozero&#39;</span><span class="p">:</span> <span class="n">cv</span><span class="o">.</span><span class="n">THRESH_TOZERO</span><span class="p">,</span>
            <span class="s1">&#39;tozero_inv&#39;</span><span class="p">:</span> <span class="n">cv</span><span class="o">.</span><span class="n">THRESH_TOZERO_INV</span><span class="p">,</span>
            <span class="s1">&#39;otsu&#39;</span><span class="p">:</span> <span class="n">cv</span><span class="o">.</span><span class="n">THRESH_OTSU</span><span class="p">,</span>
            <span class="s1">&#39;triangle&#39;</span><span class="p">:</span> <span class="n">cv</span><span class="o">.</span><span class="n">THRESH_TRIANGLE</span>
        <span class="p">}</span>

        <span class="k">if</span> <span class="n">t</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">argcheck</span><span class="o">.</span><span class="n">isscalar</span><span class="p">(</span><span class="n">t</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="s1">&#39;t must be a scalar&#39;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># if no threshold is specified, we assume to use Otsu&#39;s method</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;No threshold specified. Applying Otsu&#39;&#39;s method.&#39;</span><span class="p">)</span>
            <span class="n">opt</span> <span class="o">=</span> <span class="s1">&#39;otsu&#39;</span>
            <span class="c1"># note: opencv&#39;s otsu&#39;s method only works on 8-bit single-channel images</span>
            <span class="c1"># thus, apply conversion automatically</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Image converted to uint8, as higher-bit images not yet supported&#39;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">int</span><span class="p">()</span>

        <span class="c1"># ensure mono images</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">iscolor</span><span class="p">:</span>
            <span class="n">imono</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">mono</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">imono</span> <span class="o">=</span> <span class="bp">self</span>

        <span class="n">out_t</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">out_imt</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">im</span> <span class="ow">in</span> <span class="p">[</span><span class="n">img</span><span class="o">.</span><span class="n">image</span> <span class="k">for</span> <span class="n">img</span> <span class="ow">in</span> <span class="n">imono</span><span class="p">]:</span>

            <span class="c1"># for image int class, maxval = max of int class</span>
            <span class="c1"># for image float class, maxval = 1</span>
            <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">issubdtype</span><span class="p">(</span><span class="n">im</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">integer</span><span class="p">):</span>
                <span class="n">maxval</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">iinfo</span><span class="p">(</span><span class="n">im</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span><span class="o">.</span><span class="n">max</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># float image, [0, 1] range</span>
                <span class="n">maxval</span> <span class="o">=</span> <span class="mf">1.0</span>

            <span class="n">threshvalue</span><span class="p">,</span> <span class="n">imt</span> <span class="o">=</span> <span class="n">cv</span><span class="o">.</span><span class="n">threshold</span><span class="p">(</span><span class="n">im</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">maxval</span><span class="p">,</span> <span class="n">threshopt</span><span class="p">[</span><span class="n">opt</span><span class="p">])</span>
            <span class="n">out_t</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">threshvalue</span><span class="p">)</span>
            <span class="n">out_imt</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">imt</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">opt</span> <span class="o">==</span> <span class="s1">&#39;otsu&#39;</span> <span class="ow">or</span> <span class="n">opt</span> <span class="o">==</span> <span class="s1">&#39;triangle&#39;</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">(</span><span class="n">out_imt</span><span class="p">),</span> <span class="n">out_t</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">(</span><span class="n">out_imt</span><span class="p">)</span></div>

<div class="viewcode-block" id="ImageProcessingBaseMixin.otsu"><a class="viewcode-back" href="../../imageproc.html#machinevisiontoolbox.ImageProcessingBase.ImageProcessingBaseMixin.otsu">[docs]</a>    <span class="k">def</span> <span class="nf">otsu</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">levels</span><span class="o">=</span><span class="mi">256</span><span class="p">,</span> <span class="n">valley</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Otsu threshold selection</span>

<span class="sd">        :return t: Otsu&#39;s threshold</span>
<span class="sd">        :rtype t: float</span>
<span class="sd">        :return imt: Image thresholded to a binary image</span>
<span class="sd">        :rtype imt: Image instance</span>

<span class="sd">        - ``otsu(im)`` is an optimal threshold for binarizing an image with a</span>
<span class="sd">          bimodal intensity histogram.  ``t`` is a scalar threshold that</span>
<span class="sd">          maximizes the variance between the classes of pixels below and above</span>
<span class="sd">          the thresold ``t``.</span>

<span class="sd">        Example::</span>

<span class="sd">        .. runblock:: pycon</span>

<span class="sd">        .. note::</span>

<span class="sd">            - Converts a color image to greyscale.</span>

<span class="sd">        :references:</span>

<span class="sd">            - A Threshold Selection Method from Gray-Level Histograms, N. Otsu.</span>
<span class="sd">              IEEE Trans. Systems, Man and Cybernetics Vol SMC-9(1), Jan 1979,</span>
<span class="sd">              pp 62-66.</span>
<span class="sd">            - An improved method for image thresholding on the valley-emphasis</span>
<span class="sd">              method. H-F Ng, D. Jargalsaikhan etal. Signal and Info Proc.</span>
<span class="sd">              Assocn. Annual Summit and Conf (APSIPA). 2013. pp1-4</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># mvt-mat has options on levels and valleys, which Opencv does not have</span>
        <span class="c1"># TODO best option is likely just to code the function itself, with</span>
        <span class="c1"># default option of simply calling OpenCV&#39;s Otsu implementation</span>

        <span class="n">im</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">mono</span><span class="p">()</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">valley</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">):</span>
            <span class="n">imt</span><span class="p">,</span> <span class="n">t</span> <span class="o">=</span> <span class="n">im</span><span class="o">.</span><span class="n">thresh</span><span class="p">(</span><span class="n">opt</span><span class="o">=</span><span class="s1">&#39;otsu&#39;</span><span class="p">)</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">valley</span><span class="p">,</span> <span class="s1">&#39;not implemented yet&#39;</span><span class="p">)</span>
            <span class="c1"># TODO implement otsu.m</span>
            <span class="c1"># TODO levels currently ignored</span>

        <span class="k">return</span> <span class="n">imt</span><span class="p">,</span> <span class="n">t</span></div>

    <span class="k">def</span> <span class="nf">nonzero</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">nonzero</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">image</span><span class="p">)</span>

<div class="viewcode-block" id="ImageProcessingBaseMixin.meshgrid"><a class="viewcode-back" href="../../imageproc.html#machinevisiontoolbox.ImageProcessingBase.ImageProcessingBaseMixin.meshgrid">[docs]</a>    <span class="k">def</span> <span class="nf">meshgrid</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">step</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Domain matrices for image</span>

<span class="sd">        :param a1: array input 1</span>
<span class="sd">        :type a1: numpy array</span>
<span class="sd">        :param a2: array input 2</span>
<span class="sd">        :type a2: numpy array</span>
<span class="sd">        :return u: domain of image, horizontal</span>
<span class="sd">        :rtype u: numpy array</span>
<span class="sd">        :return v: domain of image, vertical</span>
<span class="sd">        :rtype v: numpy array</span>

<span class="sd">        - ``IM.imeshgrid()`` are matrices that describe the domain of image</span>
<span class="sd">          ``im (h,w)`` and are each ``(h,w)``. These matrices are used for the</span>
<span class="sd">          evaluation of functions over the image. The element ``u(r,c) = c``</span>
<span class="sd">          and ``v(r,c) = r``.</span>

<span class="sd">        - ``IM.imeshgrid(w, h)`` as above but the domain is ``(w,h)``.</span>

<span class="sd">        - ``IM.imeshgrid(s)`` as above but the domain is described by ``s``</span>
<span class="sd">          which can be a scalar ``(s,s)`` or a 2-vector ``s=[w,h]``.</span>

<span class="sd">        Example:</span>

<span class="sd">        .. runblock:: pycon</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># TODO too complex, simplify</span>
        <span class="c1"># Use cases</span>
        <span class="c1">#  image.meshgrid()  spans image</span>
        <span class="c1">#  image.meshgrid(step=N) spans image with step</span>

        <span class="c1"># if not (argcheck.isvector(a1) or isinstance(a1, np.ndarray)</span>
        <span class="c1">#         or argcheck.isscalar(a1) or isinstance(a1, self.__class__)):</span>
        <span class="c1">#     raise ValueError(</span>
        <span class="c1">#         a1, &#39;a1 must be an Image, matrix, vector, or scalar&#39;)</span>
        <span class="c1"># if a2 is not None and (not (argcheck.isvector(a2) or</span>
        <span class="c1">#                             isinstance(a2, np.ndarray) or</span>
        <span class="c1">#                             argcheck.isscalar(a2) or</span>
        <span class="c1">#                             isinstance(a2, self.__class__))):</span>
        <span class="c1">#     raise ValueError(</span>
        <span class="c1">#         a2, &#39;a2 must be Image, matrix, vector, scalar or None&#39;)</span>

        <span class="c1"># if isinstance(a1, self.__class__):</span>
        <span class="c1">#     a1 = a1.image</span>
        <span class="c1"># if isinstance(a2, self.__class__):</span>
        <span class="c1">#     a2 = a2.image</span>

        <span class="c1"># if a2 is None:</span>
        <span class="c1">#     if a1.ndim &lt;= 1 and len(a1) == 1:</span>
        <span class="c1">#         # if a1 is a single number</span>
        <span class="c1">#         # we specify a size for a square output image</span>
        <span class="c1">#         ai = np.arange(0, a1)</span>
        <span class="c1">#         u, v = np.meshgrid(ai, ai)</span>
        <span class="c1">#     elif a1.ndim &lt;= 1 and len(a1) == 2:</span>
        <span class="c1">#         # if a1 is a 2-vector</span>
        <span class="c1">#         # we specify a size for a rectangular output image (w, h)</span>
        <span class="c1">#         a10 = np.arange(0, a1[0])</span>
        <span class="c1">#         a11 = np.arange(0, a1[1])</span>
        <span class="c1">#         u, v = np.meshgrid(a10, a11)</span>
        <span class="c1">#     elif (a1.ndim &gt;= 2):  # and (a1.shape[2] &gt; 2):</span>
        <span class="c1">#         u, v = np.meshgrid(np.arange(0, a1.shape[1]),</span>
        <span class="c1">#                            np.arange(0, a1.shape[0]))</span>
        <span class="c1">#     else:</span>
        <span class="c1">#         raise ValueError(a1, &#39;incorrect argument a1 shape&#39;)</span>
        <span class="c1"># else:</span>
        <span class="c1">#     # we assume a1 and a2 are two scalars</span>
        <span class="c1">#     u, v = np.meshgrid(np.arange(0, a1), np.arange(0, a2))</span>

        <span class="n">u</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">width</span><span class="p">,</span> <span class="n">step</span><span class="p">)</span>
        <span class="n">v</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">height</span><span class="p">,</span> <span class="n">step</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">meshgrid</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">u</span><span class="p">,</span> <span class="n">indexing</span><span class="o">=</span><span class="s1">&#39;ij&#39;</span><span class="p">)</span></div>


<div class="viewcode-block" id="ImageProcessingBaseMixin.hist"><a class="viewcode-back" href="../../imageproc.html#machinevisiontoolbox.ImageProcessingBase.ImageProcessingBaseMixin.hist">[docs]</a>    <span class="k">def</span> <span class="nf">hist</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">nbins</span><span class="o">=</span><span class="mi">256</span><span class="p">,</span> <span class="n">opt</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Image histogram</span>

<span class="sd">        :param nbins: number of bins for histogram</span>
<span class="sd">        :type nbins: integer</span>
<span class="sd">        :param opt: histogram option</span>
<span class="sd">        :type opt: string</span>
<span class="sd">        :return hist: histogram h as a column vector, and corresponding bins x,</span>
<span class="sd">        cdf and normcdf</span>
<span class="sd">        :rtype hist: collections.namedtuple</span>

<span class="sd">        - ``IM.hist()`` is the histogram of intensities for image as a vector.</span>
<span class="sd">          For an image with  multiple planes, the histogram of each plane is</span>
<span class="sd">          given in a separate column. Additionally, the cumulative histogram</span>
<span class="sd">          and normalized cumulative histogram, whose maximum value is one, are</span>
<span class="sd">          computed.</span>

<span class="sd">        - ``IM.hist(nbins)`` as above with the number of bins specified</span>

<span class="sd">        - ``IM.hist(opt)`` as above with histogram options specified</span>

<span class="sd">        :options:</span>

<span class="sd">            - &#39;sorted&#39; histogram but with occurrence sorted in descending</span>
<span class="sd">              magnitude order.  Bin coordinates X reflect this sorting.</span>

<span class="sd">        Example:</span>

<span class="sd">        .. runblock:: pycon</span>

<span class="sd">        .. note::</span>

<span class="sd">            - The bins spans the greylevel range 0-255.</span>
<span class="sd">            - For a floating point image the histogram spans the greylevel</span>
<span class="sd">              range 0-1.</span>
<span class="sd">            - For floating point images all NaN and Inf values are first</span>
<span class="sd">              removed.</span>
<span class="sd">            - OpenCV CalcHist only works on floats up to 32 bit, images are</span>
<span class="sd">              automatically converted from float64 to float32</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># check inputs</span>
        <span class="n">optHist</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;sorted&#39;</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">opt</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">opt</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">optHist</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">opt</span><span class="p">,</span> <span class="s1">&#39;opt is not a valid option&#39;</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">isint</span><span class="p">:</span>
            <span class="n">maxrange</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">iinfo</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span><span class="o">.</span><span class="n">max</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># float image</span>
            <span class="n">maxrange</span> <span class="o">=</span> <span class="mf">1.0</span>

        <span class="n">out</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">im</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">:</span>
            <span class="c1"># normal histogram case</span>

            <span class="n">xc</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">hc</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">hcdf</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">hnormcdf</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">implanes</span> <span class="o">=</span> <span class="n">cv</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="n">im</span><span class="o">.</span><span class="n">image</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">numchannels</span><span class="p">):</span>
                <span class="c1"># bin coordinates</span>
                <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">maxrange</span><span class="p">,</span> <span class="n">nbins</span><span class="p">,</span> <span class="n">endpoint</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span><span class="o">.</span><span class="n">T</span>
                <span class="n">h</span> <span class="o">=</span> <span class="n">cv</span><span class="o">.</span><span class="n">calcHist</span><span class="p">(</span><span class="n">implanes</span><span class="p">,</span> <span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="kc">None</span><span class="p">,</span> <span class="p">[</span><span class="n">nbins</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">maxrange</span> <span class="o">+</span> <span class="mi">1</span><span class="p">])</span>

                <span class="k">if</span> <span class="n">opt</span> <span class="o">==</span> <span class="s1">&#39;sorted&#39;</span><span class="p">:</span>
                    <span class="n">h</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">h</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
                    <span class="n">isort</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="n">h</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
                    <span class="n">x</span> <span class="o">=</span> <span class="n">x</span><span class="p">[</span><span class="n">isort</span><span class="p">]</span>

                <span class="n">cdf</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cumsum</span><span class="p">(</span><span class="n">h</span><span class="p">)</span>
                <span class="n">normcdf</span> <span class="o">=</span> <span class="n">cdf</span> <span class="o">/</span> <span class="n">cdf</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

                <span class="n">xc</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
                <span class="n">hc</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">h</span><span class="p">)</span>
                <span class="n">hcdf</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">cdf</span><span class="p">)</span>
                <span class="n">hnormcdf</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">normcdf</span><span class="p">)</span>

            <span class="c1"># stack into arrays</span>
            <span class="n">xs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">(</span><span class="n">xc</span><span class="p">)</span><span class="o">.</span><span class="n">T</span>
            <span class="n">hs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">(</span><span class="n">hc</span><span class="p">)</span>
            <span class="n">cs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">(</span><span class="n">hcdf</span><span class="p">)</span><span class="o">.</span><span class="n">T</span>
            <span class="n">ns</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">(</span><span class="n">hnormcdf</span><span class="p">)</span><span class="o">.</span><span class="n">T</span>

            <span class="c1"># TODO this seems too complex, why do we stack stuff as well</span>
            <span class="c1"># as have an array of hist tuples??</span>

            <span class="n">hhhx</span> <span class="o">=</span> <span class="n">Histogram</span><span class="p">(</span><span class="n">hs</span><span class="p">,</span> <span class="n">cs</span><span class="p">,</span> <span class="n">ns</span><span class="p">,</span> <span class="n">xs</span><span class="p">)</span>
            <span class="n">out</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">hhhx</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">out</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">out</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">out</span></div>

    <span class="c1"># helper function that was part of hist() in the Matlab toolbox</span>
    <span class="c1"># TODO consider moving this to ImpageProcessingBase.py</span>
<div class="viewcode-block" id="ImageProcessingBaseMixin.plothist"><a class="viewcode-back" href="../../imageproc.html#machinevisiontoolbox.ImageProcessingBase.ImageProcessingBaseMixin.plothist">[docs]</a>    <span class="k">def</span> <span class="nf">plothist</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">title</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">block</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        plot first image histogram as a line plot (TODO as poly)</span>
<span class="sd">        NOTE convenient, but maybe not a great solution because we then need to</span>
<span class="sd">        duplicate all the plotting options as for idisp?</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;plothist for multiple histogram objects not yet implemented&#39;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">title</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">title</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">filename</span>

        <span class="n">hist</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">hist</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">hist</span><span class="o">.</span><span class="n">xs</span>
        <span class="n">h</span> <span class="o">=</span> <span class="n">hist</span><span class="o">.</span><span class="n">hs</span>
        <span class="n">fig</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">()</span>

        <span class="c1"># line plot histogram style</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">iscolor</span><span class="p">:</span>
            <span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">x</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">h</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">],</span> <span class="s1">&#39;b&#39;</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">0.8</span><span class="p">)</span>
            <span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">x</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">h</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">],</span> <span class="s1">&#39;g&#39;</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">0.8</span><span class="p">)</span>
            <span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">x</span><span class="p">[:,</span> <span class="mi">2</span><span class="p">],</span> <span class="n">h</span><span class="p">[:,</span> <span class="mi">2</span><span class="p">],</span> <span class="s1">&#39;r&#39;</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">0.8</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">h</span><span class="p">,</span> <span class="s1">&#39;k&#39;</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">0.7</span><span class="p">)</span>

        <span class="c1"># polygon histogram style</span>
        <span class="n">polygon_style</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">if</span> <span class="n">polygon_style</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">iscolor</span><span class="p">:</span>
                <span class="kn">from</span> <span class="nn">matplotlib.patches</span> <span class="kn">import</span> <span class="n">Polygon</span>
                <span class="c1"># TODO make sure pb goes to bottom of axes at the edges:</span>
                <span class="n">pb</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">stack</span><span class="p">((</span><span class="n">x</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">h</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
                <span class="n">polyb</span> <span class="o">=</span> <span class="n">Polygon</span><span class="p">(</span><span class="n">pb</span><span class="p">,</span>
                                <span class="n">closed</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                                <span class="n">facecolor</span><span class="o">=</span><span class="s1">&#39;b&#39;</span><span class="p">,</span>
                                <span class="n">linestyle</span><span class="o">=</span><span class="s1">&#39;-&#39;</span><span class="p">,</span>
                                <span class="n">alpha</span><span class="o">=</span><span class="mf">0.75</span><span class="p">)</span>
                <span class="n">ax</span><span class="o">.</span><span class="n">add_patch</span><span class="p">(</span><span class="n">polyb</span><span class="p">)</span>

                <span class="n">pg</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">stack</span><span class="p">((</span><span class="n">x</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">h</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
                <span class="n">polyg</span> <span class="o">=</span> <span class="n">Polygon</span><span class="p">(</span><span class="n">pg</span><span class="p">,</span>
                                <span class="n">closed</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                                <span class="n">facecolor</span><span class="o">=</span><span class="s1">&#39;g&#39;</span><span class="p">,</span>
                                <span class="n">linestyle</span><span class="o">=</span><span class="s1">&#39;-&#39;</span><span class="p">,</span>
                                <span class="n">alpha</span><span class="o">=</span><span class="mf">0.75</span><span class="p">)</span>
                <span class="n">ax</span><span class="o">.</span><span class="n">add_patch</span><span class="p">(</span><span class="n">polyg</span><span class="p">)</span>

                <span class="n">pr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">stack</span><span class="p">((</span><span class="n">x</span><span class="p">[:,</span> <span class="mi">2</span><span class="p">],</span> <span class="n">h</span><span class="p">[:,</span> <span class="mi">2</span><span class="p">]),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
                <span class="n">polyr</span> <span class="o">=</span> <span class="n">Polygon</span><span class="p">(</span><span class="n">pr</span><span class="p">,</span>
                                <span class="n">closed</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                                <span class="n">facecolor</span><span class="o">=</span><span class="s1">&#39;r&#39;</span><span class="p">,</span>
                                <span class="n">linestyle</span><span class="o">=</span><span class="s1">&#39;-&#39;</span><span class="p">,</span>
                                <span class="n">alpha</span><span class="o">=</span><span class="mf">0.75</span><span class="p">)</span>
                <span class="n">ax</span><span class="o">.</span><span class="n">add_patch</span><span class="p">(</span><span class="n">polyr</span><span class="p">)</span>

                <span class="c1"># addpatch seems to require a plot, so hack is to plot null and</span>
                <span class="c1"># make alpha=0</span>
                <span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="kn">from</span> <span class="nn">matplotlib.patches</span> <span class="kn">import</span> <span class="n">Polygon</span>
                <span class="n">p</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">((</span><span class="n">x</span><span class="p">,</span> <span class="n">h</span><span class="p">))</span>
                <span class="n">poly</span> <span class="o">=</span> <span class="n">Polygon</span><span class="p">(</span><span class="n">p</span><span class="p">,</span>
                               <span class="n">closed</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                               <span class="n">facecolor</span><span class="o">=</span><span class="s1">&#39;k&#39;</span><span class="p">,</span>
                               <span class="n">linestyle</span><span class="o">=</span><span class="s1">&#39;-&#39;</span><span class="p">,</span>
                               <span class="n">alpha</span><span class="o">=</span><span class="mf">0.5</span><span class="p">)</span>
                <span class="n">ax</span><span class="o">.</span><span class="n">add_patch</span><span class="p">(</span><span class="n">poly</span><span class="p">)</span>
                <span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

        <span class="n">ax</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s1">&#39;count&#39;</span><span class="p">)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="s1">&#39;bin&#39;</span><span class="p">)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">grid</span><span class="p">()</span>

        <span class="n">ax</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="n">title</span><span class="p">)</span>

        <span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">(</span><span class="n">block</span><span class="o">=</span><span class="n">block</span><span class="p">)</span>

        <span class="c1"># him = im[2].hist()</span>
        <span class="c1"># fig, ax = plt.subplots()</span>
        <span class="c1"># ax.plot(him[i].x[:, 0], him[i].h[:, 0], &#39;b&#39;)</span>
        <span class="c1"># ax.plot(him[i].x[:, 1], him[i].h[:, 1], &#39;g&#39;)</span>
        <span class="c1"># ax.plot(him[i].x[:, 2], him[i].h[:, 2], &#39;r&#39;)</span>
        <span class="c1"># plt.show()</span>
        <span class="k">return</span> <span class="n">fig</span><span class="p">,</span> <span class="n">ax</span></div>


<div class="viewcode-block" id="ImageProcessingBaseMixin.normhist"><a class="viewcode-back" href="../../imageproc.html#machinevisiontoolbox.ImageProcessingBase.ImageProcessingBaseMixin.normhist">[docs]</a>    <span class="k">def</span> <span class="nf">normhist</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">nbins</span><span class="o">=</span><span class="mi">256</span><span class="p">,</span> <span class="n">opt</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Histogram normalisaton</span>

<span class="sd">        :param nbins: number of bins for histogram</span>
<span class="sd">        :type nbins: integer</span>
<span class="sd">        :param opt: histogram option</span>
<span class="sd">        :type opt: string</span>
<span class="sd">        :return nim: Image with normalised image</span>
<span class="sd">        :rtype nim: Image instance</span>

<span class="sd">        - ``IM.normhist()`` is a histogram normalized version of the image.</span>

<span class="sd">        Example:</span>

<span class="sd">        .. runblock:: pycon</span>

<span class="sd">        .. note::</span>

<span class="sd">            - Highlights image detail in dark areas of an image.</span>
<span class="sd">            - The histogram of the normalized image is approximately uniform,</span>
<span class="sd">              that is, all grey levels ae equally likely to occur.</span>
<span class="sd">            - Color images automatically converted to grayscale</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># check inputs</span>
        <span class="n">optHist</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;sorted&#39;</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">opt</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">opt</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">optHist</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">opt</span><span class="p">,</span> <span class="s1">&#39;opt is not a valid option&#39;</span><span class="p">)</span>

        <span class="n">img</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">mono</span><span class="p">()</span>

        <span class="c1"># if self.iscolor:</span>
        <span class="c1">#     raise ValueError(self, &#39;normhist does not support color images&#39;)</span>

        <span class="c1"># NOTE could alternatively just call cv.equalizeHist()? However,</span>
        <span class="c1"># cv.equalizeHist only accepts 8-bit images, while normhist can</span>
        <span class="c1"># accept float images as well.</span>
        <span class="c1"># return cv.equalizeHist(im) cdf = hist(im, &#39;cdf&#39;)</span>

        <span class="n">hcnx</span> <span class="o">=</span> <span class="n">img</span><span class="o">.</span><span class="n">hist</span><span class="p">(</span><span class="n">nbins</span><span class="p">,</span> <span class="n">opt</span><span class="p">)</span>

        <span class="n">out</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">im</span> <span class="ow">in</span> <span class="n">img</span><span class="p">:</span>
            <span class="c1"># j = 0  # channel (only 1 channel due to mono)</span>
            <span class="k">if</span> <span class="n">im</span><span class="o">.</span><span class="n">isfloat</span><span class="p">:</span>
                <span class="n">f</span> <span class="o">=</span> <span class="n">interpolate</span><span class="o">.</span><span class="n">interp1d</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="n">hcnx</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">x</span><span class="p">),</span>
                                         <span class="n">np</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="n">hcnx</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">normcdf</span><span class="p">),</span>
                                         <span class="n">kind</span><span class="o">=</span><span class="s1">&#39;nearest&#39;</span><span class="p">)</span>
                <span class="n">nim</span> <span class="o">=</span> <span class="n">f</span><span class="p">(</span><span class="n">im</span><span class="o">.</span><span class="n">image</span><span class="o">.</span><span class="n">flatten</span><span class="p">())</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">f</span> <span class="o">=</span> <span class="n">interpolate</span><span class="o">.</span><span class="n">interp1d</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="n">hcnx</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">x</span><span class="p">),</span>
                                         <span class="n">np</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="n">hcnx</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">normcdf</span><span class="p">),</span>
                                         <span class="n">kind</span><span class="o">=</span><span class="s1">&#39;nearest&#39;</span><span class="p">)</span>
                <span class="c1"># turn image data to float but scaled to im.dtype max</span>
                <span class="n">imy</span> <span class="o">=</span> <span class="n">im</span><span class="o">.</span><span class="n">float</span><span class="p">()</span><span class="o">.</span><span class="n">image</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span> <span class="o">*</span> \
                    <span class="nb">float</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">iinfo</span><span class="p">(</span><span class="n">im</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span><span class="o">.</span><span class="n">max</span><span class="p">)</span>
                <span class="n">nim</span> <span class="o">=</span> <span class="n">f</span><span class="p">(</span><span class="n">imy</span><span class="p">)</span>

            <span class="c1"># reshape back into image format</span>
            <span class="n">nimr</span> <span class="o">=</span> <span class="n">nim</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">im</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">im</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">order</span><span class="o">=</span><span class="s1">&#39;C&#39;</span><span class="p">)</span>

            <span class="n">o</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">(</span><span class="n">nimr</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">im</span><span class="o">.</span><span class="n">isfloat</span><span class="p">:</span>
                <span class="n">o</span> <span class="o">=</span> <span class="n">o</span><span class="o">.</span><span class="n">float</span><span class="p">()</span>  <span class="c1"># nim = np.float32(nim)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">o</span> <span class="o">=</span> <span class="n">o</span><span class="o">.</span><span class="n">int</span><span class="p">()</span>

            <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="n">out</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">o</span><span class="p">)</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">(</span><span class="n">out</span><span class="p">)</span></div>

<div class="viewcode-block" id="ImageProcessingBaseMixin.replicate"><a class="viewcode-back" href="../../imageproc.html#machinevisiontoolbox.ImageProcessingBase.ImageProcessingBaseMixin.replicate">[docs]</a>    <span class="k">def</span> <span class="nf">replicate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">M</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Expand image</span>

<span class="sd">        :param M: number of times to replicate image</span>
<span class="sd">        :type M: integer</span>
<span class="sd">        :return out: Image expanded image</span>
<span class="sd">        :rtype out: Image instance</span>

<span class="sd">        - ``IM.replicate(M)`` is an expanded version of the image (H,W) where</span>
<span class="sd">          each pixel is replicated into a (M,M) tile. If ``im`` is (H,W) the</span>
<span class="sd">          result is ((M*H),(M*W)) numpy array.</span>

<span class="sd">        Example:</span>

<span class="sd">        .. runblock:: pycon</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">out</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">im</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">im</span><span class="o">.</span><span class="n">ndims</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="p">:</span>
                <span class="c1"># dealing with multiplane image</span>
                <span class="c1"># TODO replace with a list comprehension</span>
                <span class="n">ir2</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">im</span><span class="o">.</span><span class="n">numchannels</span><span class="p">):</span>
                    <span class="n">im1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">(</span><span class="n">im</span><span class="o">.</span><span class="n">image</span><span class="p">[:,</span> <span class="p">:,</span> <span class="n">i</span><span class="p">])</span>
                    <span class="n">ir2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">im1</span><span class="o">.</span><span class="n">replicate</span><span class="p">(</span><span class="n">M</span><span class="p">))</span>
                <span class="k">return</span> <span class="n">ir2</span>

            <span class="n">nr</span> <span class="o">=</span> <span class="n">im</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">nc</span> <span class="o">=</span> <span class="n">im</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>

            <span class="c1"># replicate columns</span>
            <span class="n">ir</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">M</span> <span class="o">*</span> <span class="n">nr</span><span class="p">,</span> <span class="n">nc</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">im</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">M</span><span class="p">):</span>
                <span class="n">ir</span><span class="p">[</span><span class="n">r</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">:</span><span class="n">M</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">im</span><span class="o">.</span><span class="n">image</span>

            <span class="c1"># replicate rows</span>
            <span class="n">ir2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">M</span> <span class="o">*</span> <span class="n">nr</span><span class="p">,</span> <span class="n">M</span> <span class="o">*</span> <span class="n">nc</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">im</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">M</span><span class="p">):</span>
                <span class="n">ir2</span><span class="p">[:,</span> <span class="n">c</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">:</span><span class="n">M</span><span class="p">]</span> <span class="o">=</span> <span class="n">ir</span>
            <span class="n">out</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ir2</span><span class="p">)</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">(</span><span class="n">out</span><span class="p">)</span></div>

<div class="viewcode-block" id="ImageProcessingBaseMixin.decimate"><a class="viewcode-back" href="../../imageproc.html#machinevisiontoolbox.ImageProcessingBase.ImageProcessingBaseMixin.decimate">[docs]</a>    <span class="k">def</span> <span class="nf">decimate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">m</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">sigma</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Decimate an image</span>

<span class="sd">        :param m: decimation factor TODO probably not the correct term</span>
<span class="sd">        :type m: integer</span>
<span class="sd">        :param sigma: standard deviation for Gaussian kernel smoothing</span>
<span class="sd">        :type sigma: float</span>
<span class="sd">        :return out: Image decimated image</span>
<span class="sd">        :rtype out: Image instance</span>

<span class="sd">        - ``IM.idecimate(m)`` is a decimated version of the image whose size is</span>
<span class="sd">          reduced by m (an integer) in both dimensions.  The image is smoothed</span>
<span class="sd">          with a Gaussian kernel with standard deviation m/2 then subsampled.</span>

<span class="sd">        - ``IM.idecimate(m, sigma)`` as above but the standard deviation of the</span>
<span class="sd">          smoothing kernel is set to ``sigma``.</span>

<span class="sd">        .. note::</span>

<span class="sd">            - If the image has multiple planes, each plane is decimated.</span>
<span class="sd">            - Smoothing is used to eliminate aliasing artifacts and the</span>
<span class="sd">              standard deviation should be chosen as a function of the maximum</span>
<span class="sd">              spatial frequency in the image.</span>

<span class="sd">        Example:</span>

<span class="sd">        .. runblock:: pycon</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">m</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="n">m</span><span class="p">))</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="s1">&#39;decimation factor m must be an integer&#39;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">sigma</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">sigma</span> <span class="o">=</span> <span class="n">m</span> <span class="o">/</span> <span class="mi">2</span>

        <span class="c1"># smooth image</span>
        <span class="n">ims</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">smooth</span><span class="p">(</span><span class="n">sigma</span><span class="p">)</span>

        <span class="c1"># decimate image</span>
        <span class="n">out</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">im</span> <span class="ow">in</span> <span class="n">ims</span><span class="p">:</span>
            <span class="n">out</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">im</span><span class="o">.</span><span class="n">image</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">:</span><span class="n">m</span><span class="p">,</span> <span class="mi">0</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">:</span><span class="n">m</span><span class="p">,</span> <span class="p">:])</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">(</span><span class="n">out</span><span class="p">)</span></div>

<div class="viewcode-block" id="ImageProcessingBaseMixin.testpattern"><a class="viewcode-back" href="../../imageproc.html#machinevisiontoolbox.ImageProcessingBase.ImageProcessingBaseMixin.testpattern">[docs]</a>    <span class="k">def</span> <span class="nf">testpattern</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">w</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Create test images</span>

<span class="sd">        :param t: pattern type</span>
<span class="sd">        :type t: string</span>
<span class="sd">        :param w: image size of output pattern image</span>
<span class="sd">        :type w: integer or 2-element vector</span>
<span class="sd">        :param args: arguments for test patterns</span>
<span class="sd">        :type args: float (varies)</span>
<span class="sd">        :param kwargs: keyword arguments for test patterns? Not currently used</span>
<span class="sd">        :type kwargs: dictionary</span>
<span class="sd">        :return z: test pattern image</span>
<span class="sd">        :rtype z: numpy array</span>

<span class="sd">        - ``testpattern(type, w, args)`` creates a test pattern image.  If</span>
<span class="sd">          ``w`` is a scalar the output image has shape ``(w,w)`` else if</span>
<span class="sd">          ``w=(w,h)`` the output image shape is ``(w,h)``.  The image is</span>
<span class="sd">          specified by the string ``t`` and one or two (type specific)</span>
<span class="sd">          arguments:</span>

<span class="sd">        :options:</span>

<span class="sd">            - &#39;rampx&#39; intensity ramp from 0 to 1 in the x-direction.</span>
<span class="sd">              ARGS is the number of cycles.</span>
<span class="sd">            - &#39;rampy&#39; intensity ramp from 0 to 1 in the y-direction.</span>
<span class="sd">              ARGS is the number of cycles.</span>
<span class="sd">            - &#39;sinx&#39; sinusoidal intensity pattern (from -1 to 1) in the</span>
<span class="sd">              x-direction. ARGS is the number of cycles.</span>
<span class="sd">            - &#39;siny&#39; sinusoidal intensity pattern (from -1 to 1) in the</span>
<span class="sd">              y-direction. ARGS is the number of cycles.</span>
<span class="sd">            - &#39;dots&#39; binary dot pattern.  ARGS are dot pitch (distance between</span>
<span class="sd">              centres); dot diameter.</span>
<span class="sd">            - &#39;squares&#39; binary square pattern.  ARGS are pitch (distance</span>
<span class="sd">              between centres); square side length.</span>
<span class="sd">            - &#39;line&#39;  a line.  ARGS are theta (rad), intercept.</span>

<span class="sd">        Example:</span>

<span class="sd">        .. runblock:: pycon</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># check valid input</span>
        <span class="n">topt</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;sinx&#39;</span><span class="p">,</span> <span class="s1">&#39;siny&#39;</span><span class="p">,</span> <span class="s1">&#39;rampx&#39;</span><span class="p">,</span> <span class="s1">&#39;rampy&#39;</span><span class="p">,</span> <span class="s1">&#39;line&#39;</span><span class="p">,</span> <span class="s1">&#39;squares&#39;</span><span class="p">,</span> <span class="s1">&#39;dots&#39;</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">t</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">topt</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="s1">&#39;t is an unknown pattern type&#39;</span><span class="p">)</span>

        <span class="n">w</span> <span class="o">=</span> <span class="n">argcheck</span><span class="o">.</span><span class="n">getvector</span><span class="p">(</span><span class="n">w</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">w</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">w</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">int</span><span class="p">(</span><span class="n">w</span><span class="p">)</span>
            <span class="n">z</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">w</span><span class="p">,</span> <span class="n">w</span><span class="p">))</span>
        <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">w</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="c1"># w = np.int(w)</span>
            <span class="n">z</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">np</span><span class="o">.</span><span class="n">int</span><span class="p">(</span><span class="n">w</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="n">np</span><span class="o">.</span><span class="n">int</span><span class="p">(</span><span class="n">w</span><span class="p">[</span><span class="mi">1</span><span class="p">])))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">w</span><span class="p">,</span> <span class="s1">&#39;w has more than two values&#39;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">t</span> <span class="o">==</span> <span class="s1">&#39;sinx&#39;</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">ncycles</span> <span class="o">=</span> <span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">ncycles</span> <span class="o">=</span> <span class="mi">1</span>
            <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">z</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
            <span class="n">c</span> <span class="o">=</span> <span class="n">z</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">/</span> <span class="n">ncycles</span>
            <span class="n">s</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">expand_dims</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">x</span> <span class="o">/</span> <span class="n">c</span> <span class="o">*</span> <span class="n">ncycles</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
            <span class="n">z</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">z</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
            <span class="c1"># z = matlib.repmat(np.sin(x / c * ncycles * 2 * np.pi),</span>
            <span class="c1">#                   z.shape[1], 1)</span>

        <span class="k">elif</span> <span class="n">t</span> <span class="o">==</span> <span class="s1">&#39;siny&#39;</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">ncycles</span> <span class="o">=</span> <span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">ncycles</span> <span class="o">=</span> <span class="mi">1</span>
            <span class="n">c</span> <span class="o">=</span> <span class="n">z</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">/</span> <span class="n">ncycles</span>
            <span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">z</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
            <span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">expand_dims</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
            <span class="c1"># z = matlib.repmat(np.sin(y / c * ncycles * 2 * np.pi),</span>
            <span class="c1">#                   1, z.shape[1])</span>
            <span class="n">z</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">y</span> <span class="o">/</span> <span class="n">c</span> <span class="o">*</span> <span class="n">ncycles</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">),</span>
                          <span class="n">z</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span>
                          <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

        <span class="k">elif</span> <span class="n">t</span> <span class="o">==</span> <span class="s1">&#39;rampx&#39;</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">ncycles</span> <span class="o">=</span> <span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">ncycles</span> <span class="o">=</span> <span class="mi">1</span>
            <span class="n">c</span> <span class="o">=</span> <span class="n">z</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">/</span> <span class="n">ncycles</span>
            <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">z</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
            <span class="c1"># z = matlib.repmat(np.mod(x, c) / (c - 1), z.shape[1], 1)</span>
            <span class="n">s</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">expand_dims</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">mod</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">c</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">c</span> <span class="o">-</span> <span class="mi">1</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
            <span class="n">z</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">z</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

        <span class="k">elif</span> <span class="n">t</span> <span class="o">==</span> <span class="s1">&#39;rampy&#39;</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">ncycles</span> <span class="o">=</span> <span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">ncycles</span> <span class="o">=</span> <span class="mi">1</span>
            <span class="n">c</span> <span class="o">=</span> <span class="n">z</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">/</span> <span class="n">ncycles</span>
            <span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">z</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
            <span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">expand_dims</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>  <span class="c1"># required due to 1D and 2D arrays</span>
            <span class="c1"># z = matlib.repmat(np.mod(y, c) / (c - 1), 1, z.shape[0])</span>
            <span class="n">z</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">mod</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">c</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">c</span> <span class="o">-</span> <span class="mi">1</span><span class="p">),</span> <span class="n">z</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

        <span class="k">elif</span> <span class="n">t</span> <span class="o">==</span> <span class="s1">&#39;line&#39;</span><span class="p">:</span>
            <span class="n">nr</span> <span class="o">=</span> <span class="n">z</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">nc</span> <span class="o">=</span> <span class="n">z</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
            <span class="n">theta</span> <span class="o">=</span> <span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">c</span> <span class="o">=</span> <span class="n">args</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>

            <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">tan</span><span class="p">(</span><span class="n">theta</span><span class="p">))</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">nc</span><span class="p">)</span>
                <span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">x</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">tan</span><span class="p">(</span><span class="n">theta</span><span class="p">)</span> <span class="o">+</span> <span class="n">c</span><span class="p">)</span>
                <span class="c1"># NOTE np.where seems to return a tuple, though it is</span>
                <span class="c1"># supposed to return an array</span>
                <span class="n">s</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">((</span><span class="n">y</span> <span class="o">&gt;=</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">y</span> <span class="o">&lt;</span> <span class="n">nr</span><span class="p">))</span>

            <span class="k">else</span><span class="p">:</span>
                <span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">nr</span><span class="p">)</span>
                <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">((</span><span class="n">y</span> <span class="o">-</span> <span class="n">c</span><span class="p">)</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">tan</span><span class="p">(</span><span class="n">theta</span><span class="p">))</span>
                <span class="c1"># note: be careful about 1 vs 0, python vs matlab indexing</span>
                <span class="n">s</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">((</span><span class="n">x</span> <span class="o">&gt;=</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">x</span> <span class="o">&lt;</span> <span class="n">nc</span><span class="p">))</span>

            <span class="c1"># s is a list - likely because np.where only returns an array if</span>
            <span class="c1"># you have two arrays as input</span>
            <span class="c1"># could probably np.where z for np.zeros(z.shape), np.ones(z.shape)</span>
            <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">s</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
                <span class="n">z</span><span class="p">[</span><span class="nb">int</span><span class="p">(</span><span class="n">y</span><span class="p">[</span><span class="n">k</span><span class="p">]),</span> <span class="nb">int</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="n">k</span><span class="p">])]</span> <span class="o">=</span> <span class="mi">1</span>

        <span class="k">elif</span> <span class="n">t</span> <span class="o">==</span> <span class="s1">&#39;squares&#39;</span><span class="p">:</span>
            <span class="n">nr</span> <span class="o">=</span> <span class="n">z</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">nc</span> <span class="o">=</span> <span class="n">z</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
            <span class="n">pitch</span> <span class="o">=</span> <span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">d</span> <span class="o">=</span> <span class="n">args</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">d</span> <span class="o">&gt;</span> <span class="p">(</span><span class="n">pitch</span> <span class="o">/</span> <span class="mi">2</span><span class="p">):</span>
                <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;warning: squares will overlap&#39;</span><span class="p">)</span>
            <span class="n">rad</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">floor</span><span class="p">(</span><span class="n">d</span> <span class="o">/</span> <span class="mi">2</span><span class="p">))</span>
            <span class="n">d</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">rad</span>
            <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">pitch</span> <span class="o">/</span> <span class="mi">2</span><span class="p">,</span> <span class="p">(</span><span class="n">nr</span> <span class="o">-</span> <span class="n">pitch</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">pitch</span><span class="p">,</span>
                               <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int</span><span class="p">):</span>
                <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">pitch</span> <span class="o">/</span> <span class="mi">2</span><span class="p">,</span> <span class="p">(</span><span class="n">nc</span> <span class="o">-</span> <span class="n">pitch</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">pitch</span><span class="p">,</span>
                                   <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int</span><span class="p">):</span>
                    <span class="c1"># for r in range(pitch / 2.0, (nr - pitch / 2.0), pitch):</span>
                    <span class="c1"># for c in range(pitch / 2.0, (nc - pitch / 2.0), pitch):</span>
                    <span class="n">z</span><span class="p">[</span><span class="n">r</span> <span class="o">-</span> <span class="n">rad</span><span class="p">:</span><span class="n">r</span> <span class="o">+</span> <span class="n">rad</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">c</span> <span class="o">-</span> <span class="n">rad</span><span class="p">:</span><span class="n">c</span> <span class="o">+</span> <span class="n">rad</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">d</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>

        <span class="k">elif</span> <span class="n">t</span> <span class="o">==</span> <span class="s1">&#39;dots&#39;</span><span class="p">:</span>
            <span class="n">nr</span> <span class="o">=</span> <span class="n">z</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">nc</span> <span class="o">=</span> <span class="n">z</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
            <span class="n">pitch</span> <span class="o">=</span> <span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">d</span> <span class="o">=</span> <span class="n">args</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">d</span> <span class="o">&gt;</span> <span class="p">(</span><span class="n">pitch</span> <span class="o">/</span> <span class="mf">2.0</span><span class="p">):</span>
                <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;warning: dots will overlap&#39;</span><span class="p">)</span>

            <span class="n">rad</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">floor</span><span class="p">(</span><span class="n">d</span> <span class="o">/</span> <span class="mi">2</span><span class="p">))</span>
            <span class="n">d</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">rad</span>
            <span class="n">s</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">kcircle</span><span class="p">(</span><span class="n">d</span> <span class="o">/</span> <span class="mf">2.0</span><span class="p">)</span>

            <span class="c1"># for r in range(pitch / 2, (nr - pitch / 2), pitch):</span>
            <span class="c1"># NOTE +1 is a hack to make np.arange include the endpoint. Surely</span>
            <span class="c1"># there&#39;s a better way?</span>
            <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">pitch</span> <span class="o">/</span> <span class="mi">2</span><span class="p">,</span> <span class="p">(</span><span class="n">nr</span> <span class="o">-</span> <span class="n">pitch</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">pitch</span><span class="p">,</span>
                               <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int</span><span class="p">):</span>
                <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">pitch</span> <span class="o">/</span> <span class="mi">2</span><span class="p">,</span> <span class="p">(</span><span class="n">nc</span> <span class="o">-</span> <span class="n">pitch</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">pitch</span><span class="p">,</span>
                                   <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int</span><span class="p">):</span>
                    <span class="n">z</span><span class="p">[</span><span class="n">r</span> <span class="o">-</span> <span class="n">rad</span><span class="p">:</span><span class="n">r</span> <span class="o">+</span> <span class="n">rad</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">c</span> <span class="o">-</span> <span class="n">rad</span><span class="p">:</span><span class="n">c</span> <span class="o">+</span> <span class="n">rad</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">s</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="s1">&#39;unknown pattern type&#39;</span><span class="p">)</span>
            <span class="n">z</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">(</span><span class="n">z</span><span class="p">)</span></div>



<div class="viewcode-block" id="ImageProcessingBaseMixin.paste"><a class="viewcode-back" href="../../imageproc.html#machinevisiontoolbox.ImageProcessingBase.ImageProcessingBaseMixin.paste">[docs]</a>    <span class="k">def</span> <span class="nf">paste</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
              <span class="n">pattern</span><span class="p">,</span>
              <span class="n">pt</span><span class="p">,</span>
              <span class="n">opt</span><span class="o">=</span><span class="s1">&#39;set&#39;</span><span class="p">,</span>
              <span class="n">centre</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
              <span class="n">zero</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Paste an image into an image</span>

<span class="sd">        :param pattern: sub-image super-imposed onto onto canvas</span>
<span class="sd">        :type pattern: numpy array</span>
<span class="sd">        :param pt: coordinates where pattern is pasted</span>
<span class="sd">        :type pt: 2-element vector of integer coordinates</span>
<span class="sd">        :param opt: options for paste settings</span>
<span class="sd">        :type opt: string</span>
<span class="sd">        :param centre: True if pattern centered at pt, else topleft of pattern</span>
<span class="sd">        :type centre: boolean</span>
<span class="sd">        :param zero: zero-based coordinates (True) or 1-based coordinates</span>
<span class="sd">        :type zero: boolean</span>
<span class="sd">        :return out: Image with pasted image</span>
<span class="sd">        :rtype out: Image instance</span>

<span class="sd">        - ``IM.paste(pattern, pt)`` is the image canvas with the subimage</span>
<span class="sd">          ``pattern`` pasted in at the position ``pt=[U, V]``.</span>

<span class="sd">        - ``IM.paste(pattern, pt, centre)`` as above with centre specified. The</span>
<span class="sd">          pasted image is centred at ``pt``, otherwise ``pt`` is the top-left</span>
<span class="sd">          corner of the subimage in the image (default).</span>

<span class="sd">        - ``IM.paste(pattern, pt, zero)`` as above with zero specified. The</span>
<span class="sd">          coordinates of ``pt`` start at zero, by default (0, 0) is assumed.</span>
<span class="sd">          TODO shouldn&#39;t this be a point? like ``origin`` or something</span>

<span class="sd">        - ``IM.paste(pattern, pt, opt)`` as above with opt specified as below.</span>

<span class="sd">        :options:</span>

<span class="sd">            - &#39;set&#39;       ``pattern`` overwrites the pixels in ``canvas``</span>
<span class="sd">              (default).</span>
<span class="sd">            - &#39;add&#39;       ``pattern`` is added to the pixels in ``canvas``.</span>
<span class="sd">            - &#39;mean&#39;      ``pattern`` is set to the mean of pixel values</span>
<span class="sd">              in ``canvas`` and ``pattern``.</span>

<span class="sd">        Example:</span>

<span class="sd">        .. runblock:: pycon</span>

<span class="sd">        .. note::</span>

<span class="sd">            - Pixels outside the pasted in region are unaffected.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># TODO can likely replace a lot of this with np.where?</span>

        <span class="c1"># check inputs</span>
        <span class="n">pt</span> <span class="o">=</span> <span class="n">argcheck</span><span class="o">.</span><span class="n">getvector</span><span class="p">(</span><span class="n">pt</span><span class="p">)</span>

        <span class="c1"># TODO check optional inputs valid</span>
        <span class="c1"># TODO need to check that centre+point+pattern combinations are valid</span>
        <span class="c1"># for given canvas size</span>
        <span class="n">out</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">canvas</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">:</span>
            <span class="n">cw</span> <span class="o">=</span> <span class="n">canvas</span><span class="o">.</span><span class="n">width</span>
            <span class="n">ch</span> <span class="o">=</span> <span class="n">canvas</span><span class="o">.</span><span class="n">height</span>
            <span class="n">pw</span> <span class="o">=</span> <span class="n">pattern</span><span class="o">.</span><span class="n">width</span>
            <span class="n">ph</span> <span class="o">=</span> <span class="n">pattern</span><span class="o">.</span><span class="n">height</span>

            <span class="n">pasteOpt</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;set&#39;</span><span class="p">,</span> <span class="s1">&#39;add&#39;</span><span class="p">,</span> <span class="s1">&#39;mean&#39;</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">opt</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">pasteOpt</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">opt</span><span class="p">,</span> <span class="s1">&#39;opt is not a valid option for paste()&#39;</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">centre</span><span class="p">:</span>
                <span class="n">left</span> <span class="o">=</span> <span class="n">pt</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">floor</span><span class="p">(</span><span class="n">pw</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span>
                <span class="n">top</span> <span class="o">=</span> <span class="n">pt</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">floor</span><span class="p">(</span><span class="n">ph</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">left</span> <span class="o">=</span> <span class="n">pt</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>  <span class="c1"># x</span>
                <span class="n">top</span> <span class="o">=</span> <span class="n">pt</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>  <span class="c1"># y</span>

            <span class="k">if</span> <span class="ow">not</span> <span class="n">zero</span><span class="p">:</span>
                <span class="n">left</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="n">top</span> <span class="o">+=</span> <span class="mi">1</span>

            <span class="c1"># indexes must be integers</span>
            <span class="n">top</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">int</span><span class="p">(</span><span class="n">top</span><span class="p">)</span>
            <span class="n">left</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">int</span><span class="p">(</span><span class="n">left</span><span class="p">)</span>

            <span class="k">if</span> <span class="p">(</span><span class="n">top</span><span class="o">+</span><span class="n">ph</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">ch</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">ph</span><span class="p">,</span> <span class="s1">&#39;pattern falls off bottom edge&#39;</span><span class="p">)</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">left</span><span class="o">+</span><span class="n">pw</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">cw</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">pw</span><span class="p">,</span> <span class="s1">&#39;pattern falls off right edge&#39;</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">pattern</span><span class="o">.</span><span class="n">iscolor</span><span class="p">:</span>
                <span class="n">npc</span> <span class="o">=</span> <span class="n">pattern</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">npc</span> <span class="o">=</span> <span class="mi">1</span>

            <span class="k">if</span> <span class="n">canvas</span><span class="o">.</span><span class="n">iscolor</span><span class="p">:</span>
                <span class="n">nc</span> <span class="o">=</span> <span class="n">canvas</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">nc</span> <span class="o">=</span> <span class="mi">1</span>

            <span class="k">if</span> <span class="n">npc</span> <span class="o">&gt;</span> <span class="n">nc</span><span class="p">:</span>
                <span class="c1"># pattern has multiple planes, replicate the canvas</span>
                <span class="c1"># sadly, this doesn&#39;t work because repmat doesn&#39;t work on 3D</span>
                <span class="c1"># arrays</span>
                <span class="c1"># o = np.matlib.repmat(canvas.image, [1, 1, npc])</span>
                <span class="n">o</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dstack</span><span class="p">([</span><span class="n">canvas</span><span class="o">.</span><span class="n">image</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">npc</span><span class="p">)])</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">o</span> <span class="o">=</span> <span class="n">canvas</span><span class="o">.</span><span class="n">image</span>

            <span class="k">if</span> <span class="n">npc</span> <span class="o">&lt;</span> <span class="n">nc</span><span class="p">:</span>
                <span class="n">pim</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dstack</span><span class="p">([</span><span class="n">pattern</span><span class="o">.</span><span class="n">image</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nc</span><span class="p">)])</span>
                <span class="c1"># pattern.image = np.matlib.repmat(pattern.image, [1, 1, nc])</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">pim</span> <span class="o">=</span> <span class="n">pattern</span><span class="o">.</span><span class="n">image</span>

            <span class="k">if</span> <span class="n">opt</span> <span class="o">==</span> <span class="s1">&#39;set&#39;</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">pattern</span><span class="o">.</span><span class="n">iscolor</span><span class="p">:</span>
                    <span class="n">o</span><span class="p">[</span><span class="n">top</span><span class="p">:</span><span class="n">top</span><span class="o">+</span><span class="n">ph</span><span class="p">,</span> <span class="n">left</span><span class="p">:</span><span class="n">left</span><span class="o">+</span><span class="n">pw</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">pim</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">o</span><span class="p">[</span><span class="n">top</span><span class="p">:</span><span class="n">top</span><span class="o">+</span><span class="n">ph</span><span class="p">,</span> <span class="n">left</span><span class="p">:</span><span class="n">left</span><span class="o">+</span><span class="n">pw</span><span class="p">]</span> <span class="o">=</span> <span class="n">pim</span>

            <span class="k">elif</span> <span class="n">opt</span> <span class="o">==</span> <span class="s1">&#39;add&#39;</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">pattern</span><span class="o">.</span><span class="n">iscolor</span><span class="p">:</span>
                    <span class="n">o</span><span class="p">[</span><span class="n">top</span><span class="p">:</span><span class="n">top</span><span class="o">+</span><span class="n">ph</span><span class="p">,</span> <span class="n">left</span><span class="p">:</span><span class="n">left</span><span class="o">+</span><span class="n">pw</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">o</span><span class="p">[</span><span class="n">top</span><span class="p">:</span><span class="n">top</span><span class="o">+</span><span class="n">ph</span><span class="p">,</span>
                                                       <span class="n">left</span><span class="p">:</span><span class="n">left</span><span class="o">+</span><span class="n">pw</span><span class="p">,</span> <span class="p">:]</span> <span class="o">+</span> <span class="n">pim</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">o</span><span class="p">[</span><span class="n">top</span><span class="p">:</span><span class="n">top</span><span class="o">+</span><span class="n">ph</span><span class="p">,</span> <span class="n">left</span><span class="p">:</span><span class="n">left</span><span class="o">+</span><span class="n">pw</span><span class="p">]</span> <span class="o">=</span> <span class="n">o</span><span class="p">[</span><span class="n">top</span><span class="p">:</span><span class="n">top</span><span class="o">+</span><span class="n">ph</span><span class="p">,</span>
                                                    <span class="n">left</span><span class="p">:</span><span class="n">left</span><span class="o">+</span><span class="n">pw</span><span class="p">]</span> <span class="o">+</span> <span class="n">pim</span>
            <span class="k">elif</span> <span class="n">opt</span> <span class="o">==</span> <span class="s1">&#39;mean&#39;</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">pattern</span><span class="o">.</span><span class="n">iscolor</span><span class="p">:</span>
                    <span class="n">old</span> <span class="o">=</span> <span class="n">o</span><span class="p">[</span><span class="n">top</span><span class="p">:</span><span class="n">top</span><span class="o">+</span><span class="n">ph</span><span class="p">,</span> <span class="n">left</span><span class="p">:</span><span class="n">left</span><span class="o">+</span><span class="n">pw</span><span class="p">,</span> <span class="p">:]</span>
                    <span class="n">k</span> <span class="o">=</span> <span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">pim</span><span class="p">)</span>
                    <span class="n">old</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="p">(</span><span class="n">old</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">+</span> <span class="n">pim</span><span class="p">[</span><span class="n">k</span><span class="p">])</span>
                    <span class="n">o</span><span class="p">[</span><span class="n">top</span><span class="p">:</span><span class="n">top</span><span class="o">+</span><span class="n">ph</span><span class="p">,</span> <span class="n">left</span><span class="p">:</span><span class="n">left</span><span class="o">+</span><span class="n">pw</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">old</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">old</span> <span class="o">=</span> <span class="n">o</span><span class="p">[</span><span class="n">top</span><span class="p">:</span><span class="n">top</span><span class="o">+</span><span class="n">ph</span><span class="p">,</span> <span class="n">left</span><span class="p">:</span><span class="n">left</span><span class="o">+</span><span class="n">pw</span><span class="p">]</span>
                    <span class="n">k</span> <span class="o">=</span> <span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">pim</span><span class="p">)</span>
                    <span class="n">old</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="p">(</span><span class="n">old</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">+</span> <span class="n">pim</span><span class="p">[</span><span class="n">k</span><span class="p">])</span>
                    <span class="n">o</span><span class="p">[</span><span class="n">top</span><span class="p">:</span><span class="n">top</span><span class="o">+</span><span class="n">ph</span><span class="p">,</span> <span class="n">left</span><span class="p">:</span><span class="n">left</span><span class="o">+</span><span class="n">pw</span><span class="p">]</span> <span class="o">=</span> <span class="n">old</span>

            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">opt</span><span class="p">,</span> <span class="s1">&#39;opt is not valid&#39;</span><span class="p">)</span>

            <span class="n">out</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">o</span><span class="p">)</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">(</span><span class="n">out</span><span class="p">)</span></div>

<div class="viewcode-block" id="ImageProcessingBaseMixin.peak2"><a class="viewcode-back" href="../../imageproc.html#machinevisiontoolbox.ImageProcessingBase.ImageProcessingBaseMixin.peak2">[docs]</a>    <span class="k">def</span> <span class="nf">peak2</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">npeaks</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">sc</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">interp</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Find peaks in a matrix</span>

<span class="sd">        :param npeaks: number of peaks to return (default all)</span>
<span class="sd">        :type npeaks: scalar</span>
<span class="sd">        :param sc: scale of peaks to consider</span>
<span class="sd">        :type sc: float</span>
<span class="sd">        :param interp:  interpolation done on peaks</span>
<span class="sd">        :type interp: boolean</span>
<span class="sd">        :return: peaks, xy locations, ap? TODO</span>
<span class="sd">        :rtype: collections.namedtuple</span>

<span class="sd">        - ``IM.peak2()`` are the peak values in the 2-dimensional signal</span>
<span class="sd">          ``IM``. Also returns the indices of the maxima in the matrix ``IM``.</span>
<span class="sd">          Use SUB2IND to convert these to row and column.</span>

<span class="sd">        - ``IM.peak2(npeaks)`` as above with the number of peaks to return</span>
<span class="sd">          specifieid (default all).</span>

<span class="sd">        - ``IM.peak2(sc)`` as above with scale ``sc`` specified. Only consider</span>
<span class="sd">          as peaks the largest value in the horizontal and vertical range +/- S</span>
<span class="sd">          units.</span>

<span class="sd">        - ``IM.peak2(interp)`` as above with interp specified. Interpolate peak</span>
<span class="sd">          (default no peak interpolation).</span>

<span class="sd">        Example:</span>

<span class="sd">        .. runblock:: pycon</span>

<span class="sd">        .. note::</span>

<span class="sd">            - A maxima is defined as an element that larger than its eight</span>
<span class="sd">              neighbours. Edges elements will never be returned as maxima.</span>
<span class="sd">            - To find minima, use PEAK2(-V).</span>
<span class="sd">            - The interp options fits points in the neighbourhood about the</span>
<span class="sd">              peak with a paraboloid and its peak position is returned.  In</span>
<span class="sd">              this case IJ will be non-integer.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># TODO check valid input</span>

        <span class="c1"># create a neighbourhood mask for non-local maxima suppression</span>
        <span class="n">h</span> <span class="o">=</span> <span class="n">sc</span>
        <span class="n">w</span> <span class="o">=</span> <span class="mi">2</span><span class="o">*</span><span class="n">h</span>
        <span class="n">M</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="n">w</span><span class="p">,</span> <span class="n">w</span><span class="p">))</span>
        <span class="n">M</span><span class="p">[</span><span class="n">h</span><span class="p">,</span> <span class="n">h</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="n">out</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">z</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">:</span>
            <span class="c1"># compute the neighbourhood maximum</span>
            <span class="n">znh</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">window</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">float</span><span class="p">(</span><span class="n">z</span><span class="p">),</span> <span class="n">M</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span><span class="p">,</span> <span class="s1">&#39;wrap&#39;</span><span class="p">)</span>

            <span class="c1"># find all pixels greater than their neighbourhood</span>
            <span class="n">k</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">z</span> <span class="o">&gt;</span> <span class="n">znh</span><span class="p">)</span>

            <span class="c1"># sort these local maxima into descending order</span>
            <span class="n">ks</span> <span class="o">=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="n">z</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)][:,</span> <span class="p">:,</span> <span class="o">-</span><span class="mi">1</span><span class="p">]</span>  <span class="c1"># TODO check this</span>
            <span class="n">k</span> <span class="o">=</span> <span class="n">k</span><span class="p">[</span><span class="n">ks</span><span class="p">]</span>

            <span class="n">npks</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">length</span><span class="p">(</span><span class="n">k</span><span class="p">),</span> <span class="n">npeaks</span><span class="p">)</span>
            <span class="n">k</span> <span class="o">=</span> <span class="n">k</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="n">npks</span><span class="p">]</span>

            <span class="n">y</span><span class="p">,</span> <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unravel_index</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">z</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
            <span class="n">xy</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">stack</span><span class="p">((</span><span class="n">y</span><span class="p">,</span> <span class="n">x</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>

            <span class="c1"># interpolate peaks if required</span>
            <span class="k">if</span> <span class="n">interp</span><span class="p">:</span>
                <span class="c1"># TODO see peak2.m, line 87-131</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">interp</span><span class="p">,</span> <span class="s1">&#39;interp not yet supported&#39;</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">xyp</span> <span class="o">=</span> <span class="n">xy</span>
                <span class="n">zp</span> <span class="o">=</span> <span class="n">z</span><span class="p">(</span><span class="n">k</span><span class="p">)</span>
                <span class="n">ap</span> <span class="o">=</span> <span class="p">[]</span>

            <span class="c1"># TODO should xyp, etc be Images?</span>
            <span class="n">o</span> <span class="o">=</span> <span class="n">namedtuple</span><span class="p">(</span><span class="s1">&#39;peaks&#39;</span><span class="p">,</span> <span class="s1">&#39;xy&#39;</span> <span class="s1">&#39;z&#39;</span> <span class="s1">&#39;a&#39;</span><span class="p">)(</span><span class="n">xyp</span><span class="p">,</span> <span class="n">zp</span><span class="p">,</span> <span class="n">ap</span><span class="p">)</span>
            <span class="n">out</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">o</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">out</span></div>

<div class="viewcode-block" id="ImageProcessingBaseMixin.roi"><a class="viewcode-back" href="../../imageproc.html#machinevisiontoolbox.ImageProcessingBase.ImageProcessingBaseMixin.roi">[docs]</a>    <span class="k">def</span> <span class="nf">roi</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">reg</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">wh</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Extract region of interest</span>

<span class="sd">        :param reg: region</span>
<span class="sd">        :type reg: numpy array</span>
<span class="sd">        :param wh: width and/or height</span>
<span class="sd">        :type wh: 2-element vector of integers, or single integer</span>
<span class="sd">        :return: Image with roi as image</span>
<span class="sd">        :rtype: Image instance</span>

<span class="sd">        - ``IM.roi(rect)`` is a subimage of the image described by the</span>
<span class="sd">          rectangle ``rect=[umin, umax; vmin, vmax]``. The function returns the</span>
<span class="sd">          top, left, bottom and top coordinates of the selected region of</span>
<span class="sd">          interest, as vectors.</span>

<span class="sd">        - ``IM.roi(reg, wh)`` as above but the region is centered at</span>
<span class="sd">          ``reg=(U,V)`` and has a size ``wh``.  If ``wh`` is scalar then</span>
<span class="sd">          ``W=H=S`` otherwise ``S=(W,H)``.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># interpret reg</span>
        <span class="k">if</span> <span class="n">reg</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">wh</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># reg = getself.__class__(reg)  # 2x2?</span>
            <span class="n">wh</span> <span class="o">=</span> <span class="n">argcheck</span><span class="o">.</span><span class="n">getvector</span><span class="p">(</span><span class="n">wh</span><span class="p">)</span>

            <span class="n">xc</span> <span class="o">=</span> <span class="n">reg</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">yc</span> <span class="o">=</span> <span class="n">reg</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">wh</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">w</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">wh</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span>
                <span class="n">h</span> <span class="o">=</span> <span class="n">w</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">w</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">wh</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span>
                <span class="n">h</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">wh</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span>
            <span class="n">left</span> <span class="o">=</span> <span class="n">xc</span> <span class="o">-</span> <span class="n">w</span>
            <span class="n">right</span> <span class="o">=</span> <span class="n">xc</span> <span class="o">+</span> <span class="n">w</span>
            <span class="n">top</span> <span class="o">=</span> <span class="n">yc</span> <span class="o">-</span> <span class="n">h</span>
            <span class="n">bot</span> <span class="o">=</span> <span class="n">yc</span> <span class="o">+</span> <span class="n">h</span>

        <span class="k">elif</span> <span class="n">reg</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">wh</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># reg = getself.__class__(reg)</span>

            <span class="n">left</span> <span class="o">=</span> <span class="n">reg</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>
            <span class="n">right</span> <span class="o">=</span> <span class="n">reg</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span>
            <span class="n">top</span> <span class="o">=</span> <span class="n">reg</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>
            <span class="n">bot</span> <span class="o">=</span> <span class="n">reg</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">reg</span><span class="p">,</span> <span class="s1">&#39;reg cannot be None&#39;</span><span class="p">)</span>

        <span class="c1"># TODO check row/column ordering, and ndim check</span>
        <span class="n">out</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">im</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">:</span>
            <span class="n">roi</span> <span class="o">=</span> <span class="n">im</span><span class="o">.</span><span class="n">image</span><span class="p">[</span><span class="n">top</span><span class="p">:</span><span class="n">bot</span><span class="p">,</span> <span class="n">left</span><span class="p">:</span><span class="n">right</span><span class="p">,</span> <span class="p">:]</span>
            <span class="n">o</span> <span class="o">=</span> <span class="n">namedtuple</span><span class="p">(</span><span class="s1">&#39;roi&#39;</span><span class="p">,</span> <span class="p">[</span><span class="s1">&#39;roi&#39;</span><span class="p">,</span>
                                   <span class="s1">&#39;left&#39;</span><span class="p">,</span>
                                   <span class="s1">&#39;right&#39;</span><span class="p">,</span>
                                   <span class="s1">&#39;top&#39;</span><span class="p">,</span>
                                   <span class="s1">&#39;bot&#39;</span><span class="p">])(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">(</span><span class="n">roi</span><span class="p">),</span>
                                           <span class="n">left</span><span class="p">,</span>
                                           <span class="n">right</span><span class="p">,</span>
                                           <span class="n">top</span><span class="p">,</span>
                                           <span class="n">bot</span><span class="p">)</span>
            <span class="n">out</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">o</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">out</span></div>

<div class="viewcode-block" id="ImageProcessingBaseMixin.pixelswitch"><a class="viewcode-back" href="../../imageproc.html#machinevisiontoolbox.ImageProcessingBase.ImageProcessingBaseMixin.pixelswitch">[docs]</a>    <span class="k">def</span> <span class="nf">pixelswitch</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mask</span><span class="p">,</span> <span class="n">im2</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Pixel-wise image merge</span>

<span class="sd">        :param mask: image mask</span>
<span class="sd">        :type mask: numpy array</span>
<span class="sd">        :param im2: image 2</span>
<span class="sd">        :type im2: numpy array</span>
<span class="sd">        :return: out</span>
<span class="sd">        :rtype: Image instance</span>

<span class="sd">        - ``IM.pixelswitch(mask, im2)`` is an image where each pixel is</span>
<span class="sd">          selected from the corresponding pixel in  image or ``im2`` according</span>
<span class="sd">          to the corresponding pixel values in ``mask``.  If the element of</span>
<span class="sd">          ``mask`` is zero image is selected, otherwise ``im2`` is selected.</span>

<span class="sd">        - ``im2`` can contain a color descriptor which is one of: a scalar</span>
<span class="sd">          value corresponding to a greyscale, a 3-vector corresponding to a</span>
<span class="sd">          color value, or a string containing the name of a color which is</span>
<span class="sd">          found using COLORNAME.</span>

<span class="sd">        Example:</span>

<span class="sd">        .. runblock:: pycon</span>

<span class="sd">        .. note::</span>

<span class="sd">            - ``im1``, ``im2`` and ``mask`` must all have the same number of</span>
<span class="sd">              rows and columns (unless ``im1`` or ``im2`` are specifying a</span>
<span class="sd">              color)</span>
<span class="sd">            - If ``im1`` and ``im2`` are both greyscale then ``out`` is</span>
<span class="sd">              greyscale.</span>
<span class="sd">            - If either of ``im1`` or ``im2`` are color then ``out`` is color.</span>
<span class="sd">            - If either one image is double and one is integer then the integer</span>
<span class="sd">              image is first converted to a double image.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># TODO add possibility for alpha layering?</span>

        <span class="c1"># interpret im1, im2 to produce an Image for each</span>
        <span class="n">im2</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_checkimage</span><span class="p">(</span><span class="n">im2</span><span class="p">,</span> <span class="n">mask</span><span class="p">)</span>
        <span class="n">im2</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">(</span><span class="n">im2</span><span class="p">)</span>

        <span class="n">out</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="c1"># &#39;for im in self:&#39; was looping twice over a single-channel 2x2</span>
        <span class="c1"># greyscale image</span>
        <span class="c1"># below, converts self into a list of Image objects, each one of which</span>
        <span class="c1"># is im</span>

        <span class="k">for</span> <span class="n">im</span> <span class="ow">in</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">(</span><span class="n">img</span><span class="p">)</span> <span class="k">for</span> <span class="n">img</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">listimages</span><span class="p">()]:</span>
            <span class="c1"># make consistent image.dtype</span>
            <span class="k">if</span> <span class="n">im</span><span class="o">.</span><span class="n">isfloat</span> <span class="ow">and</span> <span class="n">im2</span><span class="o">.</span><span class="n">isint</span><span class="p">:</span>
                <span class="n">im2</span> <span class="o">=</span> <span class="n">im2</span><span class="o">.</span><span class="n">float</span><span class="p">()</span>
            <span class="k">elif</span> <span class="n">im</span><span class="o">.</span><span class="n">isint</span> <span class="ow">and</span> <span class="n">im2</span><span class="o">.</span><span class="n">isfloat</span><span class="p">:</span>
                <span class="n">im</span> <span class="o">=</span> <span class="n">im</span><span class="o">.</span><span class="n">float</span><span class="p">()</span>

            <span class="c1"># check consistent shape (height, width only):</span>
            <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">im</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">2</span><span class="p">]</span> <span class="o">!=</span> <span class="n">im2</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">2</span><span class="p">]):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">im2</span><span class="p">,</span> <span class="s1">&#39;im1 and im2 must have the same shape&#39;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">im</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">2</span><span class="p">]</span> <span class="o">!=</span> <span class="n">mask</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">2</span><span class="p">]):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">mask</span><span class="p">,</span> <span class="s1">&#39;im1 and mask must have the same shape&#39;</span><span class="p">)</span>
            <span class="c1"># by extension, mask.shape == im2.shape</span>

            <span class="c1"># np.where returns im1 where mask == 0, and im2 where mask == 1</span>
            <span class="c1"># apply mask to each numchannel</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">iscolor</span><span class="p">:</span>
                <span class="n">cmask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dstack</span><span class="p">([</span><span class="n">mask</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">im</span><span class="o">.</span><span class="n">numchannels</span><span class="p">)])</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># greyscale image</span>
                <span class="n">cmask</span> <span class="o">=</span> <span class="n">mask</span>
            <span class="n">o</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">cmask</span><span class="p">,</span> <span class="n">im</span><span class="o">.</span><span class="n">image</span><span class="p">,</span> <span class="n">im2</span><span class="o">.</span><span class="n">image</span><span class="p">))</span>
            <span class="n">out</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">o</span><span class="p">)</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">(</span><span class="n">out</span><span class="p">)</span></div>

    <span class="k">def</span> <span class="nf">_checkimage</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">im</span><span class="p">,</span> <span class="n">mask</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Check image and mask for pixelswitch</span>

<span class="sd">        :param im: image, possibly a color vector or identifier</span>
<span class="sd">        :type im: numpy array or scalar or string</span>
<span class="sd">        :param mask: mask</span>
<span class="sd">        :type mask: numpy array</span>
<span class="sd">        :return: out</span>
<span class="sd">        :rtype: Image instance</span>

<span class="sd">        - ``_checkimage(im, mask)`` is an image the same shape as ``mask``, and</span>
<span class="sd">          might be an image of all one color, depending on the value of ``im``</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">im</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="c1"># image is a string color name</span>
            <span class="n">col</span> <span class="o">=</span> <span class="n">color</span><span class="o">.</span><span class="n">colorname</span><span class="p">(</span><span class="n">im</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">col</span> <span class="ow">is</span> <span class="p">[]:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">im</span><span class="p">,</span> <span class="s1">&#39;unknown color&#39;</span><span class="p">)</span>
            <span class="n">out</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">mask</span><span class="o">.</span><span class="n">shape</span><span class="p">))</span>
            <span class="n">out</span> <span class="o">=</span> <span class="n">out</span><span class="o">.</span><span class="n">colorise</span><span class="p">(</span><span class="n">col</span><span class="p">)</span>

        <span class="k">elif</span> <span class="n">argcheck</span><span class="o">.</span><span class="n">isscalar</span><span class="p">(</span><span class="n">im</span><span class="p">):</span>
            <span class="c1"># image is a  scalar, create a greyscale image the same size</span>
            <span class="c1"># as mask</span>
            <span class="c1"># TODO not certain if im.dtype works if im is scalar</span>
            <span class="n">out</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">mask</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">im</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span> <span class="o">*</span> <span class="n">im</span>

        <span class="k">elif</span> <span class="n">im</span><span class="o">.</span><span class="n">ndim</span> <span class="o">&lt;</span> <span class="mi">3</span> <span class="ow">and</span> <span class="nb">max</span><span class="p">(</span><span class="n">im</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
            <span class="c1"># or (3,) or (3,1)</span>
            <span class="c1"># image is a (1,3), create a color image the same size as mask</span>
            <span class="n">out</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">mask</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">im</span><span class="o">.</span><span class="n">dtype</span><span class="p">))</span>
            <span class="n">out</span> <span class="o">=</span> <span class="n">out</span><span class="o">.</span><span class="n">colorise</span><span class="p">(</span><span class="n">im</span><span class="p">)</span>

        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">im</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">):</span>
            <span class="c1"># image class, check dimensions: (NOTE: im.size, not im.shape)</span>
            <span class="c1"># here, we are assuming mask is a 2D matrix</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">im</span><span class="o">.</span><span class="n">size</span> <span class="o">==</span> <span class="n">mask</span><span class="o">.</span><span class="n">shape</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="n">im</span><span class="p">,</span> <span class="s1">&#39;input image size does not confirm with mask&#39;</span><span class="p">)</span>
            <span class="n">out</span> <span class="o">=</span> <span class="n">im</span><span class="o">.</span><span class="n">image</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># actual image, check the dimensions</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">im</span><span class="o">.</span><span class="n">shape</span> <span class="o">==</span> <span class="n">mask</span><span class="o">.</span><span class="n">shape</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="n">im</span><span class="p">,</span> <span class="s1">&#39;input image sizes (im or mask) do not conform&#39;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">out</span></div>

<span class="k">class</span> <span class="nc">Histogram</span><span class="p">:</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">hs</span><span class="p">,</span> <span class="n">cs</span><span class="p">,</span> <span class="n">ns</span><span class="p">,</span> <span class="n">xs</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">hs</span> <span class="o">=</span> <span class="n">hs</span> <span class="c1"># histogram</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">cs</span> <span class="o">=</span> <span class="n">cs</span> <span class="c1"># cumulative histogram</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ns</span> <span class="o">=</span> <span class="n">ns</span> <span class="c1"># normalized cumulative histogram</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">xs</span> <span class="o">=</span> <span class="n">xs</span>  <span class="c1"># x value</span>
        <span class="c1"># &#39;hist&#39;, &#39;h cdf normcdf x&#39;)</span>

    <span class="k">def</span> <span class="fm">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="sa">f</span><span class="s2">&quot;histogram with </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cs</span><span class="p">)</span><span class="si">}</span><span class="s2"> bins&quot;</span>

    <span class="k">def</span> <span class="nf">plot</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="nb">type</span><span class="o">=</span><span class="s1">&#39;histogram&#39;</span><span class="p">,</span> <span class="n">block</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>

        <span class="k">if</span> <span class="nb">type</span> <span class="o">==</span> <span class="s1">&#39;histogram&#39;</span><span class="p">:</span>
            <span class="n">plot_histogram</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">xs</span><span class="o">.</span><span class="n">flatten</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">hs</span><span class="o">.</span><span class="n">flatten</span><span class="p">(),</span> <span class="n">block</span><span class="o">=</span><span class="n">block</span><span class="p">,</span>
            <span class="n">xlabel</span><span class="o">=</span><span class="s1">&#39;pixel value&#39;</span><span class="p">,</span> <span class="n">ylabel</span><span class="o">=</span><span class="s1">&#39;number of pixels&#39;</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">type</span> <span class="o">==</span> <span class="s1">&#39;cumulative&#39;</span><span class="p">:</span>
            <span class="n">plot_histogram</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">xs</span><span class="o">.</span><span class="n">flatten</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">cs</span><span class="o">.</span><span class="n">flatten</span><span class="p">(),</span> <span class="n">block</span><span class="o">=</span><span class="n">block</span><span class="p">,</span>
            <span class="n">xlabel</span><span class="o">=</span><span class="s1">&#39;pixel value&#39;</span><span class="p">,</span> <span class="n">ylabel</span><span class="o">=</span><span class="s1">&#39;cumulative number of pixels&#39;</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">type</span> <span class="o">==</span> <span class="s1">&#39;normalized&#39;</span><span class="p">:</span>
            <span class="n">plot_histogram</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">xs</span><span class="o">.</span><span class="n">flatten</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">ns</span><span class="o">.</span><span class="n">flatten</span><span class="p">(),</span> <span class="n">block</span><span class="o">=</span><span class="n">block</span><span class="p">,</span>
            <span class="n">xlabel</span><span class="o">=</span><span class="s1">&#39;pixel value&#39;</span><span class="p">,</span> <span class="n">ylabel</span><span class="o">=</span><span class="s1">&#39;normalized cumulative number of pixels&#39;</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

<span class="c1"># --------------------------------------------------------------------------#</span>
<span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s1">&#39;__main__&#39;</span><span class="p">:</span>

    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;ImageProcessingBase.py&#39;</span><span class="p">)</span>

    <span class="kn">from</span> <span class="nn">machinevisiontoolbox</span> <span class="kn">import</span> <span class="n">Image</span>

    <span class="n">im</span> <span class="o">=</span> <span class="n">Image</span><span class="p">(</span><span class="s1">&#39;penguins.png&#39;</span><span class="p">,</span> <span class="n">grey</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

    <span class="n">h</span> <span class="o">=</span> <span class="n">im</span><span class="o">.</span><span class="n">hist</span><span class="p">()</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">h</span><span class="p">)</span>
    <span class="n">h</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">block</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
</pre></div>

           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright .
      <span class="lastupdated">Last updated on 31-Dec-2022.
      </span></p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>